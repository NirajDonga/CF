{
    "C++ Problem Template": {
        "prefix": "solveint",
        "body": [
            "#include <bits/stdc++.h>",
            "#define int long long int",
            "#define pb push_back",
            "#define cy cout << \"Yes\" << endl",
            "#define cn cout << \"No\" << endl",
            "#define all(a) a.begin(), a.end()",
            "#define endl '\\n'",
            "using namespace std;",
            "",
            "void solve() {",
            "    int n;",
            "    cin >> n;",
            "    bool flag = 0;",
            "    vector<int> a(n);",
            "",
            "    for (int i = 0; i < n; i++) {",
            "        cin >> a[i];",
            "    }",
            "}",
            "",
            "signed main() {",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(0);",
            "    cout.tie(0);",
            "",
            "    int tc = 1;",
            "    cin >> tc;",
            "    while (tc-- > 0) {",
            "        solve();",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "C++ Competitive Programming Template"
    },
    
    "segmentTreeFunctions": {
        "prefix": "segment tree",
        "body": [
            "template<typename T> class SegmentTree {",
            "public:",
            "    vector<T> seg;",
            "    SegmentTree(ll n) { seg.resize(4 * n); }",
            "    void build(ll i, ll low, ll high, ll l, ll r) {",
            "        if (low > high) return;",
            "        if (low >= l && high <= r) {",
            "            seg[i]++;",
            "            return;",
            "        }",
            "        if (low > r || high < l) return;",
            "        ll mid = (low + high) >> 1;",
            "        build(2 * i + 1, low, mid, l, r);",
            "        build(2 * i + 2, mid + 1, high, l, r);",
            "    }",
            "    void fill(ll i, ll low, ll high, T pval, vector<T> &v) {",
            "        if (low == high) {",
            "            v[low] = pval + seg[i];",
            "            return;",
            "        }",
            "        ll mid = (low + high) >> 1;",
            "        fill((2 * i) + 1, low, mid, pval + seg[i], v);",
            "        fill((2 * i) + 2, mid + 1, high, pval + seg[i], v);",
            "    }",
            "};",
            "",
        ],
        "description": "Segment tree functions build and fill."
    },
    "SegmentTree Template": {
        "prefix": "lazysegmenttree",
        "body": [
            "template <typename T>",
            "class SegmentTree {",
            "public:",
            "    vector<T> seg, lazy;",
            "",
            "    SegmentTree(ll size) {",
            "        seg.resize(4 * size);",
            "        lazy.resize(4 * size);",
            "    }",
            "",
            "    // Build function for the segment tree",
            "    void build(ll i, ll low, ll high, ll l, ll r) {",
            "        if (lazy[i] != 0) {",
            "            seg[i] += (high - low + 1) * lazy[i];",
            "            if (low != high) {",
            "                lazy[2 * i + 1] += lazy[i];",
            "                lazy[2 * i + 2] += lazy[i];",
            "            }",
            "            lazy[i] = 0;",
            "        }",
            "        if (low > high || low > r || high < l) return;",
            "        if (low >= l && high <= r) {",
            "            seg[i] += (high - low + 1);",
            "            if (low != high) {",
            "                lazy[2 * i + 1]++;",
            "                lazy[2 * i + 2]++;",
            "            }",
            "            return;",
            "        }",
            "        ll mid = (low + high) >> 1;",
            "        build(2 * i + 1, low, mid, l, r);",
            "        build(2 * i + 2, mid + 1, high, l, r);",
            "    }",
            "",
            "    void fill(ll i, ll low, ll high, ll pval, vector<T> &v) {",
            "        if (lazy[i] != 0) {",
            "            seg[i] += (high - low + 1) * lazy[i];",
            "            if (low != high) {",
            "                lazy[2 * i + 1] += lazy[i];",
            "                lazy[2 * i + 2] += lazy[i];",
            "            }",
            "            lazy[i] = 0;",
            "        }",
            "        if (low == high) {",
            "            v[low] = pval + seg[i];",
            "            return;",
            "        }",
            "        ll mid = (low + high) >> 1;",
            "        fill(2 * i + 1, low, mid, pval + seg[i], v);",
            "        fill(2 * i + 2, mid + 1, high, pval + seg[i], v);",
            "    }",
            "};"
        ],
        "description": "Segment tree template with build and fill methods"
    },
    "fhstring class": {
        "prefix": "stringhash",
        "body": [
            "class fhstring {",
            "private:",
            "    vector<ll> dp;",
            "    vector<ll> inv;",
            "    ll n;",
            "    ll base;",
            "    ll mod;",
            "",
            "public:",
            "    fhstring(const string& s, ll base, ll mod) : base(base), mod(mod) {",
            "        n = s.size();",
            "        dp.resize(n);",
            "        inv.resize(n);",
            "",
            "        vector<ll> p_pow(n, 1);",
            "",
            "        inv[0] = 1;",
            "        dp[0] = (s[0] - '0' + 1);",
            "",
            "        for (ll j = 1; j < n; ++j) {",
            "            char c = s[j];",
            "            p_pow[j] = (p_pow[j - 1] * base) % mod;",
            "            inv[j] = binPow(p_pow[j], mod - 2, mod);",
            "            dp[j] = (dp[j - 1] + (c - '0' + 1) * p_pow[j]) % mod;",
            "        }",
            "    }",
            "",
            "    static ll binPow(ll a, ll b, ll mod) {",
            "        ll res = 1;",
            "        while (b > 0) {",
            "            if (b & 1)",
            "                res = (res * a) % mod;",
            "            b >>= 1;",
            "            a = (a * a) % mod;",
            "        }",
            "        return res;",
            "    }",
            "",
            "    ll substrhash(ll L, ll R) {",
            "        if (R < L) return 0;",
            "        ll res = dp[R];",
            "        if (L > 0) {",
            "            res = (res - dp[L - 1] + mod) % mod;",
            "            res = (res * inv[L]) % mod;",
            "        }",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "fhstring class for fast hashing of substrings using a rolling hash"
    },    

    "template": {
        "prefix": "cpp_template",
        "body": [
            "#include <bits/stdc++.h>",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace std;",
            "using namespace __gnu_pbds;",
            "",
            "#define ll long long int",
            "#define pb push_back",
            "#define cy cout << \"Yes\" << endl",
            "#define cn cout << \"No\" << endl",
            "#define all(a) a.begin(), a.end()",
            "#define endl '\\n'",
            "#define mod (int)1e9+7",
            "",
            "typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;",
            "",
            "ll gcdExtended(ll a, ll b, ll &x, ll &y) { if (b == 0) { x = 1; y = 0; return a; } ll x1, y1; ll gcd = gcdExtended(b, a % b, x1, y1); x = y1; y = x1 - (a / b) * y1; return gcd; }",
            "ll modinverse(ll n) { ll x, y; ll g = gcdExtended(n, mod, x, y); if (g != 1) return -1; else return (x % mod + mod) % mod; }",
            "ll gcd(ll a, ll b) { if (b == 0) return a; return gcd(b, a % b); }",
            "ll power(ll a, ll b, ll m) { ll ans = 1; while (b > 0) { if (b & 1) ans = (ans * a) % m; a = (a * a) % m; b = b >> 1; } return ans; }",
            "ll modinverseprime(ll n) { return power(n, mod - 2, mod); }",
            "ll fact(ll n) { ll ans = 1; for (ll i = 2; i <= n; i++) ans = (ans * i) % mod; return ans; }",
            "ll nCr(ll n, ll r) { if (r > n || r < 0) return 0; return ((fact(n) * modinverse(fact(n - r)) % mod) * modinverse(fact(r)) % mod) % mod; }",
            "",
            "ll summation(ll a, ll b) { return (a % mod + b % mod) % mod; }",
            "ll multiplication(ll a, ll b) { return ((a % mod) * (b % mod)) % mod; }",
            "ll subtraction(ll a, ll b) { return ((a % mod - b % mod + mod) % mod); }",
            "ll division(ll a, ll b) { return ((a % mod) * (modinverse(b % mod) % mod)) % mod; }",
            "",
            "void printMap(map<ll, ll>& m) { for (auto it : m) { cout << it.first << \" \" << it.second << endl; } cout << endl; }",
            "void printSet(set<ll>& st) { for (auto it : st) { cout << it << \" \"; } cout << endl; }",
            "void printMat(vector<vector<ll>>& dp) { for (int i = 0; i < dp.size(); i++) { for (int j = 0; j < dp[0].size(); j++) { cout << dp[i][j] << \" \"; } cout << endl; } cout << endl; }",
            "",
            "bool compare(const pair<int, int>& a, const pair<int, int>& b) { return a.first < b.first; }",
            "",
            "void solve() { ",
            "    ll n; ",
            "    cin >> n; ",
            "    ",
            "    vector<ll> a(n); ",
            "    ",
            "    for (int i = 0; i < n; i++) cin >> a[i]; ",
            "}",
            "",
            "signed main() {",
            "    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);",
            "    int tc = 1; ",
            "    // cin >> tc;",
            "    while (tc-- > 0) solve();",
            "    return 0;",
            "}"
        ],
        "description": "Template for solving problems with STL and pbds in C++"
    },

    "DisjointSet": {
        "prefix": "DisjointSet",
        "body": [
            "class DisjointSet {",
            "public:",
            "    vector<int> parent, size;",
            "",
            "    DisjointSet(int n) {",
            "        parent.resize(n + 1);",
            "        size.resize(n + 1);",
            "        for (int i = 0; i <= n; i++) {",
            "            parent[i] = i;",
            "            size[i] = 1;",
            "        }",
            "    }",
            "",
            "    int findUPar(int node) {",
            "        if (node == parent[node])",
            "            return node;",
            "        return parent[node] = findUPar(parent[node]);",
            "    }",
            "",
            "    void unionBySize(int u, int v) {",
            "        int ulp_u = findUPar(u);",
            "        int ulp_v = findUPar(v);",
            "        if (ulp_u == ulp_v) return;",
            "        if (size[ulp_u] < size[ulp_v]) {",
            "            parent[ulp_u] = ulp_v;",
            "            size[ulp_v] += size[ulp_u];",
            "        } else {",
            "            parent[ulp_v] = ulp_u;",
            "            size[ulp_u] += size[ulp_v];",
            "        }",
            "    }",
            "};"
        ],
        "description": "Disjoint Set Union-Find with path compression and union by size"
    }

    
}
